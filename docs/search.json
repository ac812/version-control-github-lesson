[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "First steps in Version Control with GitHub",
    "section": "",
    "text": "Welcome"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Baker, Monya. 2016. “1,500 Scientists Lift the Lid on\nReproducibility.” Nature 533. https://doi.org/10.1038/533452a."
  },
  {
    "objectID": "chapter1.html#the-importance-of-making-research-code-accessible",
    "href": "chapter1.html#the-importance-of-making-research-code-accessible",
    "title": "1  Version Control Systems",
    "section": "1.1 The importance of making research code accessible",
    "text": "1.1 The importance of making research code accessible\nIn research, the dissemination of results is a common practice, but there exists a critical gap. While publishing data when publishing a research manuscript is getting more established, publishing the code used to get these results is not. A striking revelation from 2016 Nature survey conducted by Monya Baker Baker (2016) of 1,576 researchers underscores the issue: more than 70% of researchers struggled to reproduce another scientist’s experiments, and a staggering 50% encountered difficulties in reproducing their own experiments. This alarming trend sheds light on a pressing crisis in research reproducibility, jeopardizing the credibility of scientific findings.\nThe heart of the matter lies in the omission of research scripts and code - the very essence of the analytical processes shaping research outcomes. While research papers document results, the absence of the scripts used to generate these findings poses a significant barrier to the reproducibility of experiments. In an era where openness and collaboration are championed, this discrepancy in sharing the tools that drive research threatens the very foundation of scientific enquiry."
  },
  {
    "objectID": "chapter1.html#introduction-to-version-control-systems",
    "href": "chapter1.html#introduction-to-version-control-systems",
    "title": "1  Version Control Systems",
    "section": "1.2 Introduction to Version Control Systems",
    "text": "1.2 Introduction to Version Control Systems\nChances are that you have encountered been using a form of version control system before without realising. Consider the scenario below in Figure 1.1, where a PhD student sends their final manuscript draft to their supervisor. The supervisor sends back the document with comments and feedback to the student, renaming the document with a new version name. Before you know it, this iterative exchange has resulted into 22 versions of the file. Renaming and tracking the progression of the manuscript exemplifies a basic version control method.\n\n\n\nFigure 1.1: Different versions of document from a PhD student and a supervisor\n\n\nA version control system, in essence, is a tool that keeps track of the changes and versions of a file. This facilitates collaboration amongst multiple individuals working on the same project concurrently. Version control systems allows users to compare changes between different versions of the file, revert changes, and track who, when and why modifications were made within the team.\nVersion control systems are popular in the software development industry as it allows teams to have a common location or repository where all the source code/files in the project are kept and thus allowing team members to work on the same project concurrently in a collaborative way, tracking their contributions to the project. However, increasingly, researchers from different domains are using version control systems, in an effort to make their analysis transparent and accessible enabling reproducibility of their work.\nThe main advantages of version control systems are:\n\nVersioning: Every time someone makes a change to a file, a version of that file is stored by the version control system. This removes the need to rename the files manually to keep track of the different versions.\nCollaboration: Version control systems allow more than one person to work on the same file at the same time. This collaborative feature fosters efficient teamwork, as contributors seamlessly integrate their modifications into a shared project.\nBackup: While not being their primary role, version control systems safeguards against data loss. By storing code on a server or in the cloud, these systems serve as an inadvertent backup solution, mitigating the risk of losing all work in the event of a computer breakdown.\n\n\n\n\n\n\n\nNew keyword: repository\n\n\n\nIn version control systems, a repository is a data structure that stores files and directory structure in it, as well as the history of changes made to those files. This is similar to folders on your computer.\n\n\n\n\n\n \n\nFigure 1.2: A simplified example to explain the use of repositories in version control systems. Please press the forward arrows to go through the example step by step.\n\n\n\n\nVersion control systems are often categorised as either centralised version control systems or distributed version control systems.\n\n1.2.1 Centralised Version Control Systems\nIn a centralised version control system, the project files are stored in a central place (server) which also keeps track of the files’ history (versions). This setup allows people to collaborate on the same project with users able to commit or make changes to a central server. Normally multiple users are not able to work on the same file concurrently in a centralised version control system. The user working on a file would normally “lock” a file for editing, restricting editing access to other users. Examples of centralised version control systems are CVS and Subversion (SVN). Them main disadvantage of these systems are that if the server goes down, none of the users will be able to collaborate or get the latest versions of the files from the repository.\n\n\n\nFigure 1.3: Centralised Version Control System. Image by Michael Ernst.\n\n\n\n\n1.2.2 Distributed Version Control Systems\nIn a distributed version control system each person in a team working on a project makes a copy or clones the repository on their own computer which also includes the full history of the different files inside the repository. Thus if a server goes down, it would be able to be restored back from the copies of the repositories held by the different people in the team. Distributed version control systems are becoming increasingly more popular as they overcome some of the limitations imposed by centralised version control systems. In this course we will be learning about git which is an example of a distributed version control system.\n\n\n\nFigure 1.4: Distributed Version Control System. Image by Michael Ernst.\n\n\n\n\n\n\nBaker, Monya. 2016. “1,500 Scientists Lift the Lid on Reproducibility.” Nature 533. https://doi.org/10.1038/533452a."
  },
  {
    "objectID": "chapter2.html",
    "href": "chapter2.html",
    "title": "2  GitHub",
    "section": "",
    "text": "2.0.1 Creating a repository on GitHub\n\n\n\n\n\n \n\nFigure 2.1: A simplified example to explain the use of repositories in version control systems. Please press the forward arrows to go through the example step by step."
  },
  {
    "objectID": "chapter2.html#what-is-github",
    "href": "chapter2.html#what-is-github",
    "title": "2  GitHub",
    "section": "2.1 What is GitHub?",
    "text": "2.1 What is GitHub?\nGitHub is a cloud-based platform driven by the open-source community that hosts a vast amount of repositories and files. It uses the Git open-source version control system; the tool needed to keep track of your files’/repositories’ history. GitHub essentially makes it easier to use the Git version control system as it provides a user friendly interface to make the required operations to host and version your source code. Without GitHub, using Git normally requires knowledge in command line which can be challenging for users that do not have a technical background. Once your files are on GitHub, you would be able to share the link to your repositories with your colleagues and allow collaborative development of your source code.\nSo let’s get started using GitHub!\n\n\n\n\n\n\nExercise 1: Exploring GitHub\n\n\n\nIf you have not done so already, create a GitHub account by following instruction on github.com. If you already have a GitHub account, please log in now.\nIdentify a few GitHub organisations by writing a name of an organisation. Once you enter the organisation page, explore how the different repositories and identify the different components present on the webpage of the organisation and repositories.\nIf you do not have any organisation in mind, have a look at the GitHub organisations below:\n\nLibrary Carpentry Lessons\nData Carpentry Lessons\nHadley Wickham\nThis course notes\n\n\n\n\n2.1.1 Creating a repository on GitHub\nLet’s get started by creating a repository in our own GitHub organisation.\n\n\n\n\n\n\nExercise 2: Creating a repository on GitHub\n\n\n\nIn this example we will learn how to:\n\ncreate a repository on GitHub\ncreate a new file and add it to the repository\n\n\n\n\n\n\n \n\nFigure 2.1: Step-by-step instructions on how to create a repository on GitHub. Please click on the forward arrows to go through the instructions one step at a time. Click on the three vertical dots to enter in full screen mode to see the slides better.\n\n\n\n\n\n\n2.1.2 Issues - keeping track of tasks\nIn the previous example we have learnt how to create a repository and a file. One feature that is very useful in GitHub to help in the project management of your code are issues. Issues are created to suggest an idea, improvements or keep track of bugs, in other words, it can be viewed as a task list for the project. Issues are very useful especially when working collaboratively. They are very simple to use and are often ways to have a discussion between collaborators on a particular issue.\n\n\n\n\n\n\nExercise 3: Creating an issue\n\n\n\nIn this example we will learn how to create an issue and add a label to it to categorise it appropriately (for example; bug, enhancement, help wanted, etc…).\n\n\n\n\n\n \n\nFigure 2.2: Step-by-step instructions on how to create an issue. Please click on the forward arrows to go through the instructions one step at a time. Click on the three vertical dots to enter in full screen mode to see the slides better.\n\n\n\n\n\n\n2.1.3 Creating a branch\nSo far we have been working directly on the main branch of our repository as by default a repository has one branch named main. A branch is a separate version of the main repository. The main branch is considered as the stable version of the code that you are working on. If you want to add a new feature or additions to your code, having a separate branch to work on is considered good practice as it will retain a stable version of your code in the main branch, while developing the new feature in a separate branch. The edits done in the feature branches will not show up in the main branch until they are merged into the main branch.\n\n\n\nFigure 2.3: Representation of a main and feature branch. When creating a new branch off the main branch, the new feature branch will be a copy of the main branch at that point in time.\n\n\nFigure 2.4 shows an example of how feature branches are used in development. In the example below, the main repository contains 4 files. Developer 1 creates a feature branch feature-1 from the main branch. They make changes to file 1 and file 3 and merge these changes to the main branch. While developer 1 was working in the feature-1 branch, developer 2 also created a feature branch feature-2 from the main branch. They worked on files 2 and 4 and merged their changes back into the main branch. At the end of the process, the main branch contains all the changes from the feature-1 and feature-2 branch. The feature branches created by the two separate developers show how feature branches facilitate development from multiple developers concurrently.\n\n\n\nFigure 2.4: Creation of feature branches and merging into main. Image is an adaptation of the image from Prabhu Vingnesh Kimar Rajagopal.\n\n\n\n\n2.1.4 The GitHub flow\nA better way of describing the process above is via the GitHub workflow. There are several different workflows, e.g., git-flow, GitHub flow and GitLab flow. It is not the scope of this course to get into details about the different software development versioning models. However, we will look briefly at GitHub flow which is one of the simple workflows available, with the aim to understand the basic constructs of software development versioning models so that we can adopt good practices when sharing code or working in teams. The main rule of the GitHub flow is that anything in the main branch is deployable. The main branch is the central branch which reflects what is deployed. Therefore the main branch should always be in a ready state and stable.\nThe GitHub flow steps consist of the following:\n\nCreate a branch: If you want to make changes to the files present in the main branch, you will need to create a new branch off of the main branch; we will refer to this as a feature branch. Name this feature branch with a descriptive name that reflects the change that you would like to do e.g. fix-issue1, add-chapter1. By creating a new feature branch off the main branch, you can safely do any changes you want without worrying of breaking the main branch. When you create a branch from your main branch, you’re creating a copy of the main repository where you can add your new features or try out new ideas without effecting the main repository.\nMake changes to the files and then commit to the feature branch. Adding commits to the feature branch is important as it keeps track of the updates that you do to your files and also the reason why they were made (make sure you write clear commit messages). The creation of a feature branch allows us to keep track of any changes that are done and compare the difference between the main and the feature branch. In this way you can have multiple people working on different things at the same time as you have a stable main branch and all the other existent branches are fixes or updates that are work-in-progress to the project. Committing changes to the feature branch is also important as it helps you back up your work in case of a system failure or loss.\nOpen a pull request: Once you have tested the changes you have applied on your code to make sure that everything is running well and you are happy with the changes/commits done on the feature branch, the next step is to propose these changes to be submitted into the main branch for someone to review your work. This is done by creating a pull request. You can use the @mention system on GitHub to bring this to attention to specific people.\nDiscussion and review: The whole idea is that when you create a new pull request, this will enable a process of discussion and feedback about the changes being proposed back and forth between the developers of the main branch and yourself (the person that created the pull request). If you need to make additional changes to your feature branch after discussion, you can commit the changes to the feature branch again and then push the change. Pull requests can be written in Markdown so you can easily add images and other markdown formatting.\nMerge: Now that the code and files you have committed have passed all your testing, you can merge the changes to the existing main repository so that now they form part of the main repository. The good thing about all this process is that all the changes made during this process are preserved and anyone can track changes made in each merge and why they were made.\n\n\n\n\nFigure 2.5: GitHub flow. Please note that master in the image is now referred to as main. Image by GitHub.\n\n\n\n\n\n\n\n\nExercise 4: GitHub flow in action\n\n\n\nLevel: \nIn this exercise we will be going over the GitHub flow in action. We will fix the issue that we have opened in Exercise 3 above. We will do this by creating a feature branch which will hold the changes related to fixing this issue. A pull request will be then sent to inform which changes in the feature branch are ready. These changes are then merged into the main branch.\n\n\n\n\n\n \n\nFigure 2.6: Step-by-step instructions of the GitHub flow. Please click on the forward arrows to go through the instructions one step at a time. Click on the three vertical dots to enter in full screen mode to see the slides better.\n\n\n\n\n\n\n2.1.5 Working collaboratively\nWhen you are working on someone else’s repository, you would need to first fork the repository, i.e., make a copy of someone else’s repository into your GitHub account so that you now have the same repository present in your list of repositories. You will not be able to make changes directly on someone else’s repository unless you are a collaborator in that repository. You will then need to follow the GitHub flow process. The example below, provides you with a step-by-step example of how two people worked together collaborately on GitHub.\n\n\n\n\n\n\nExercise 5: Working collaboratively in GitHub\n\n\n\nLevel: \nIn this exercise, we will be looking at an example of how two people can work collaboratively on GitHub on the same project. In groups of two, go over the example, one of you will take the role of the Developer and the other taking the role of the Maintainer. In the example, the Developer wants to change the GitHub.txt file present in the repository of the Maintainer. See how they can do this, using the GitHub flow.\n\n\n\n\n\n \n\nFigure 2.7: Step-by-step example of two users working collaboratively on GitHub. Please click on the forward arrows to go through the instructions one step at a time. Click on the three vertical dots to enter in full screen mode to see the slides better.\n\n\nReferring again to the GitHub flow diagram (see Figure 2.5), reflect how the steps you have made together map to the different steps of the GitHub flow process. The GitHub flow is the process used as a good practice when working collaboratively. It might feel a bit complex if this is your first time doing this, but the more you practice the more it will get easier."
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "First steps in Version Control with GitHub",
    "section": "Acknowledgements",
    "text": "Acknowledgements\n\nThanks to Mary Chester-Kadwell for guidance.\nThis course was created as part of the CDH RSE Fellowship.\nSome of the content of this course was adapted from the Reproducible Research in R course (Cardona, Alexia 2019)"
  },
  {
    "objectID": "index.html#course-overview",
    "href": "index.html#course-overview",
    "title": "First steps in Version Control with GitHub",
    "section": "Course overview",
    "text": "Course overview\n\n\n\n\n\n\n\nDescription  Version control helps you to write code for your research more sustainably and collaboratively, in line with best practices for open research. You might use code for collecting, analysing or visualising your data, or something else. Everyone who codes in some way can benefit from learning about version control for their daily workflow.  This workshop will cover the importance of version control when developing code and foster a culture of best practices in FAIR (Findable, Accessible, Interoperable, Reproducible) code development. We will take you through the basic use of GitHub to help you store, manage, and track changes to your code and develop code collaboratively with others.\n\n\nPrerequisites  While prior knowledge of a programming language (e.g., R or Python) would be beneficial, it is not a prerequisite.\n\n\nLearning Outcomes\n\n\nexplain what version control systems and identify their advantages and importance in open research\n\n\ncreate repositories on GitHub\n\n\ncommit changes to files in repositories on GitHub\n\n\nopen issues on GitHub\n\n\ncreate branches on GitHub\n\n\nopen pull requests and merge changes into the main branch\n\n\ndescribe the GitHub flow and be able to execute it\n\n\n\n\nTarget Audience Designed with beginners in mind, this workshop caters to those who have not yet delved into Git or GitHub.\n\nLevel: Beginner\n\n\n\n\nExercises levels\nExercises in this course are labelled with the level of difficulty of the respective exercise. These levels are designed to provide a gradual progression in difficulty, allowing learners to build on their skills and understanding as they move from one level to the next.\n\n\n\n\n\n\n\nLevel\nDescription\n\n\n\n\n\nLevel 1: Exercises in Level 1 are simple exercises designed to get you familiar with a concept or syntax.\n\n\n\nLevel 2: Exercises in Level 2 build upon the concepts introduced.\n\n\n\nLevel 3: Exercises in Level 3 are more complex and build upon concepts introduced."
  },
  {
    "objectID": "index.html#citing-this-course",
    "href": "index.html#citing-this-course",
    "title": "First steps in Version Control with GitHub",
    "section": "Citing this course",
    "text": "Citing this course\nPlease cite as: Alexia Cardona. (2024, February 25). First steps in version control with GitHub. Zenodo. https://doi.org/10.5281/zenodo.10703130"
  }
]